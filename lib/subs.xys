  include_once "..\const\include.xys";

  perm $ENGLISH = 1;
  perm $SWEDISH = 0;
  perm $SUB_WRONG_LANGUAGE = -1;

  /* Subtitle functions for XYplorer-scripting  */

  /* Checks if folder contains an english subtitle (extension en.srt)  */
  function hasEnSub($path){
    $files = listFiles($path, "en.srt");
    if($files != ""){
      return 1;
    }
    else{
      return 0;
    }
  }

  /* Checks if folder contains an english subtitle (extension sv.srt)  */
  function hasSvSub($path){
    $files = listFiles($path, "sv.srt");
    if($files != ""){
      return 1;
    }
    else {
      return 0;
    }
  }

  /*  Get "points" for subtitle, to determine if it is in english/swedish/HI */
  function pointsSub($srt_file, $lang) {
    $words = "";
    $check_hi = 0;
    $subtitle_text = readfile($srt_file);
    $points = 0;

    switch ($lang) {
      case "en":
        $words = readfile($engSubTxt);
        break;
      case "sv":
        $words = readfile($sweSubTxt);
        break;
      case "hi":
        $words = readfile($hiSubTxt);
        $check_hi = 1;
        break;
      default:
        echo "Wrong language!";
        return $SUB_WRONG_LANGUAGE;
    }

    /*  Iterate trhough word in language text-files */
    foreach($word, $words, <crlf>) {
      /*  Check word matches in srt-file, with trailing and leading space */
      if($check_hi){
        $matches = regexmatches($subtitle_text, $word, "|");
      }
      else {
        $matches = regexmatches($subtitle_text, "\s" . $word . "\s", "|");
      }

      /*  Points is equal to amount of word matches */
      $points = $points + gettoken($matches, "count", "|");
    }
    return $points;
  }

  /* Determines language of srt subtitle  */
  function getSubLanguage($file){
    $enPt = pointsSub($file, "en");
    $svPt = pointsSub($file, "sv");
    /* Return 1 if english sub, 0 if swedish  */
    return ($enPt > $svPt);
  }
